women
df[,2]
df <- data.frame(
name = c("John", "Mary", "David", "Sarah"),
age = c(25, 30, 22, 27),
city = c("New York", "Los Angeles", "Chicago", "Houston")
)
df[,2]
df[2,2]
df
df[,2]
names(df)
names(df)[,2]
names(df)[2]
rownames(df)
rownames(df)[2]
dim(df)
# Define two vectors
a <- c(1, 2, 3)
b <- c(1.001, 2.002, 3.003)
# Compare the vectors using all.equal()
all.equal(a, b)
identical(a,b)
plot(circumference  ̃ age, data = Orange, pch=as.numeric(Orange$Tree))
for (i in 1:5) lines(circumference  ̃ age,
for (i in 1:5) lines(circumference~ age,
data = subset(Orange, tree == i), lty = i)
plot(circumference~age, data = Orange, pch=as.numeric(Orange$Tree))
for (i in 1:5) lines(circumference~ age,
data = subset(Orange, tree == i), lty = i)
legend("topleft", legend = paste("Tree", 1:5), lty = 1:5, pch = 1:5)
plot(circumference~age, data = Orange, pch=as.numeric(Orange$tree))
for (i in 1:5)
lines(circumference~ age, data = subset(Orange, tree == i), lty = i)
legend("topleft", legend = paste("Tree", 1:5), lty = 1:5, pch = 1:5)
legend("topleft", legend = paste("tree", 1:5), lty = 1:5, pch = 1:5)
Orange
plot(circumference~age, data = Orange, pch=as.numeric(Orange$Tree))
for (i in 1:5)
lines(circumference~age, data = subset(Orange, Tree == i), lty = i)
legend("topleft", legend = paste("tree", 1:5), lty = 1:5, pch = 1:5)
dotplot(women)
women
dotplot(height~weight, data = women)
barplot(height~weight, data = women)
barplot(height~weight, data = women, main = "women plot")
barplot(height~weight, data = women, main = "women plot", cex:0.5)
barplot(height~weight, data = women, main = "women plot", xlab=" lol")
xyplot(women)
library(DAAG)
install.packages(DAAG)
"DAAG"
library(DAAG)
installed.packages()
install.packages("DAAG")
library(DAAG)
head(litters)
litters
head(litters)
# Fit the logistic regression model
simlog <- glm(factor(Gender) ~ Height , family="binomial")
# Fit the logistic regression model
simlog <- glm(factor(Gender) ~ Height , family="binomial")
# Fit the logistic regression model
simlog <- glm(factor(Gender) ~ Height , family="binomial")
library(cars)
library(car)
install.packages("car")
library(car)
car
To test the hypothesis
To test the hypothesis
source("~/.active-rstudio-document")
# Load the car package
library(car)
# Fit the model
model_a = lm(y ~ x1 + x2 + x3 + x4)
library(car)
car
mpg
library(car)
cars
women
source("C:/Users/agarp/DATA310/a3/test.R")
clear
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
source("C:/Users/agarp/DATA310/a3/test.R")
clear
ls
clear
# Load the data
source("nickel.R")
setwd("C:/Users/agarp/data315/a3")
# Load the data
source("nickel.R")
# Compute and plot the ACF
acf(nickel, lag.max = 10, main = "ACF of Electroless Nickel Concentrations")
lynx
acf(lynx, lag.max = 10, main = "ACF of Number of lynx trapped
)
''
")"
"
# Load the built-in lynx dataset
data(lynx)
# Compute and plot the ACF
acf(lynx, lag.max = 10, main = "ACF of Lynx Trapping Data")
source("Globaltemps.R")
source("Globaltemps.R")
temps <- ts(temps, start = 1880, end = 2016)
acf(temps, lag.max = 10, main = "ACF of Global Average Temperatures")
# Load built-in dataset
data("EuStockMarkets")
# Extract DAX stock index
dax <- EuStockMarkets[, 1]
# Convert to time series object (if needed)
dax_ts <- ts(dax, start = c(1991, 1), frequency = 260)  # 260 trading days per year
# Load built-in dataset
data("EuStockMarkets")
# Extract DAX stock index
dax <- EuStockMarkets[, 1]
# Convert to time series object (if needed)
dax_ts <- ts(dax, start = c(1991, 1), frequency = 260)  # 260 trading days per year
plot(dax_ts, main = "DAX Stock Index Time Series", ylab = "Index Value", xlab = "Year", col = "blue", type = "l")
acf(dax_ts, main = "ACF of DAX Stock Index")
diff(ln(dax_ts))
log_dax <- log(dax_ts)          # Take the natural log
diff_log_dax <- diff(log_dax)   # Compute first differences (log returns)
plot(diff_log_dax, main = "Log Differences of DAX Index (Log Returns)", ylab = "Log Returns", xlab = "Year", col = "red", type = "l")
set.seed(123)
wn <- rnorm(100)  # White noise
par(mfrow=c(1,2))
plot.ts(wn, main="White Noise Time Series")
acf(wn, main="ACF of White Noise")
ma1 <- arima.sim(model = list(ma=0.5), n=100)
par(mfrow=c(1,2))
plot.ts(ma1, main="MA(1) Time Series")
acf(ma1, main="ACF of MA(1)")
ar1 <- arima.sim(model = list(ar=0.7), n=100)
par(mfrow=c(1,2))
plot.ts(ar1, main="AR(1) Time Series")
acf(ar1, main="ACF of AR(1)")
ma1_model <- arima(nickel_data, order = c(0, 0, 1))
temps
source("nickle.R")
source("nickel.R")
ma1_model <- arima(nickel, order = c(0, 0, 1))
summary(ma1_model)
print(ma1_model)
Box.test(ma1_model$residuals, lag = 10, type = "Ljung-Box")
predict(ma1_model, n.ahead = 3)
summary(ma1_model)
print(ma1_model)
# Load necessary library
library(stats)
# Fit MA(1) model
ma1_model <- arima(nickel, order = c(0, 0, 1))
# Print the model summary
summary(ma1_model)
ma1_model
> # Load necessary library
ma1_model
ma1_model
# Load necessary library
library(forecast)
install.packages('forecast')
# Load necessary library
library(forecast)
# Define the time series
nickel <- ts(c(4.8, 4.8, 4.5, 4.5, 4.4, 4.2, 4.4, 4.5, 5, 4.2, 4.8, 4.5, 4.4,
4.6, 4.3, 4.5, 4.7, 4.4, 4.5, 4.4, 4.5, 4.7, 4.7, 4.6, 4.4, 4.7,
4.8, 4.6, 4.5, 4.6, 4.3, 4.3, 4.5, 4.8, 4.5, 4.6, 4.4, 4.7, 4.6,
4.5, 4.8, 4.7, 4.5, 4.6, 4.7, 4.7, 5, 4.7, 4.8, 4.6, 4.4, 4.8,
4.9, 4.6, 4.3, 4.7, 4.6, 4.8, 4.8, 4.9, 4.9, 4.6, 4.6, 4.8, 4.9,
4.9, 4.7, 4.7, 4.7, 4.8, 4.7, 4.9, 5.2, 4.4, 4.3), frequency=3)
# Fit an MA(1) model
fit <- arima(nickel, order = c(0, 0, 1))
# Display the fitted model
summary(fit)
# Hypothesis test for MA(1) parameter
ma_coef <- fit$coef["ma1"]
ma_se <- sqrt(diag(fit$var.coef))["ma1"]
z_value <- ma_coef / ma_se
p_value <- 2 * (1 - pnorm(abs(z_value)))
p_value  # If p-value < 0.05, reject H0: MA(1) = 0
# Forecast the next 3 values
forecast_values <- forecast(fit, h = 3)
forecast_values
library(forecast)
library(tseries)
ma_model <- arima(ts(nickel), order = c(0, 0, 1))
summary(ma_model)
# Load necessary library
library(stats)
# Fit MA(1) model
ma1_model <- arima(nickel, order = c(0, 0, 1))
# Print the model summary
summary(ma1_model)
# Extract MA(1) coefficient and its standard error
theta_hat <- ma1_model$coef["ma1"]
se_theta <- sqrt(ma1_model$var.coef["ma1", "ma1"])
# Compute t-statistic
t_value <- theta_hat / se_theta
t_value
2 * (1 - pnorm(2.057))
# Extract MA(1) coefficient and its standard error
theta_hat <- ma1_model$coef["ma1"]
se_theta <- sqrt(ma1_model$var.coef["ma1", "ma1"])
# Compute t-statistic
t_value <- theta_hat / se_theta
# Compute p-value (two-tailed test)
p_value <- 2 * (1 - pnorm(abs(t_value)))
# Print results
t_value
p_value
# Perform Ljung-Box test on residuals with 10 lags
Box.test(ma1_model$residuals, lag = 10, type = "Ljung-Box")
library(forecast)
checkresiduals(ma1_model)
# Perform Ljung-Box test on residuals with 10 lags
Box.test(ma1_model$residuals, lag = 10, type = "Ljung-Box")
library(forecast)
checkresiduals(ma1_model)
library(forecast)
checkresiduals(ma1_model)
# Extract last residual
epsilon_74 <- residuals(ma1_model)[74]
# Compute forecast
X_75_hat <- 4.6223 + (0.2260 * epsilon_74)
X_75_hat
epsilon_74
# Extract last residual
epsilon_74 <- residuals(ma1_model)[74]
# Compute forecast
X_75_hat <- 4.6223 + (0.2260 * epsilon_74)
X_75_hat
sigma_forecast <- sqrt(0.03857) * sqrt(1 + 0.2260^2)
sigma_forecast\
sigma_forecast <- sqrt(0.03857) * sqrt(1 + 0.2260^2)
sigma_forecast
# Compute forecast error
forecast_error <- actual_X75 - X_75_hat
# Compute forecast error
forecast_error <- actual_X75 - X_75_hat
actual_X75 <- residuals(ma1_model)[75]
# Compute forecast error
forecast_error <- actual_X75 - X_75_hat
# Compute error in terms of standard deviations
z_score <- forecast_error / sigma_forecast
z_score
actual_X75 <- nickel[75]
# Compute forecast error
forecast_error <- actual_X75 - X_75_hat
# Compute error in terms of standard deviations
z_score <- forecast_error / sigma_forecast
z_score
actual_X75
# Fit AR(1) model
ar1_model <- arima(nickel, order = c(1, 0, 0))
# Print model summary
summary(ar1_model)
# Forecast 2 steps ahead
ar1_forecast <- predict(ar1_model, n.ahead = 3)
# Print forecasted values
ar1_forecast$pred
# Perform Ljung-Box test on AR(1) residuals
Box.test(ar1_model$residuals, lag = 10, type = "Ljung-Box")
# Check residual diagnostics
library(forecast)
checkresiduals(ar1_model)
# Given time series data
y <- c(3.2, 3.2, 2.2, 2.3, 1.8, 1.3, 2.2, 2.7)
# Compute the sample mean
mu_hat <- mean(y)
# Compute gamma_0 (variance)
gamma_0 <- mean((y - mu_hat)^2)
# Compute gamma_1 (lag-1 autocovariance)
gamma_1 <- mean((y[-1] - mu_hat) * (y[-length(y)] - mu_hat))
# Print the results
cat("Estimated gamma_0:", gamma_0, "\n")
cat("Estimated gamma_1:", gamma_1, "\n")
longitudinalAcceleration
# Load necessary package
library(stats)
# Assume longitudinalAcceleration is the given time series data
acf_values <- acf(longitudinalAcceleration, lag.max = 4, plot = TRUE)
install.packages("RCMinification")
longitudinalAcceleration
# Given parameters
x0 <- 10
alpha <- 0.8
timesteps <- 10
# Compute x_t for xt = 0.8 * x_{t-1}
x_values <- numeric(timesteps + 1)
x_values[1] <- x0
for (t in 2:(timesteps + 1)) {
x_values[t] <- alpha * x_values[t - 1]
}
# Plot x_t vs x_{t-1}
x_t_minus_1 <- x_values[1:timesteps]
x_t <- x_values[2:(timesteps + 1)]
plot(x_t_minus_1, x_t, type="o", col="blue", pch=16, xlab=expression(x[t-1]), ylab=expression(x[t]), main="Plot of x_t vs x_{t-1}")
grid()
# Compute x_t vs x_{t-2}
x_t_minus_2 <- x_values[1:(timesteps - 1)]
x_t_lag2 <- x_values[3:(timesteps + 1)]
plot(x_t_minus_2, x_t_lag2, type="o", col="red", pch=16, xlab=expression(x[t-2]), ylab=expression(x[t]), main="Plot of x_t vs x_{t-2}")
grid()
# Given parameters
x0 <- 10
alpha <- 0.8
timesteps <- 10
# Compute x_t for xt = 0.8 * x_{t-1}
x_values <- numeric(timesteps + 1)
x_values[1] <- x0
for (t in 2:(timesteps + 1)) {
x_values[t] <- alpha * x_values[t - 1]
}
# Plot x_t vs x_{t-1}
x_t_minus_1 <- x_values[1:timesteps]
x_t <- x_values[2:(timesteps + 1)]
plot(x_t_minus_1, x_t, type="o", col="blue", pch=16, xlab=expression(x[t-1]), ylab=expression(x[t]), main="Plot of x_t vs x_{t-1}")
grid()
# Compute x_t vs x_{t-2}
x_t_minus_2 <- x_values[1:(timesteps - 1)]
x_t_lag2 <- x_values[3:(timesteps + 1)]
plot(x_t_minus_2, x_t_lag2, type="o", col="red", pch=16, xlab=expression(x[t-2]), ylab=expression(x[t]), main="Plot of x_t vs x_{t-2}")
grid()
# Given noise values z_t
z_values <- c(-1.2, 0.2, -1.0, 0.5, 1.7, -0.5, -2.1, 1.0, 0.8, -0.1)
# Compute x_t for xt = 0.8 * x_{t-1} + z_t
x_values_noise <- numeric(timesteps + 1)
x_values_noise[1] <- x0
for (t in 2:(timesteps + 1)) {
x_values_noise[t] <- alpha * x_values_noise[t - 1] + z_values[t - 1]
}
# Plot x_t vs x_{t-1} with noise
x_t_minus_1_noise <- x_values_noise[1:timesteps]
x_t_noise <- x_values_noise[2:(timesteps + 1)]
plot(x_t_minus_1_noise, x_t_noise, type="o", col="green", pch=16, xlab=expression(x[t-1]), ylab=expression(x[t]), main="Plot of x_t vs x_{t-1} with Noise")
grid()
# Given noise values z_t
z_values <- c(-1.2, 0.2, -1.0, 0.5, 1.7, -0.5, -2.1, 1.0, 0.8, -0.1)
# Compute x_t for xt = 0.8 * x_{t-1} + z_t
x_values_noise <- numeric(timesteps + 1)
x_values_noise[1] <- x0
for (t in 2:(timesteps + 1)) {
x_values_noise[t] <- alpha * x_values_noise[t - 1] + z_values[t - 1]
}
# Plot x_t vs x_{t-1} with noise
x_t_minus_1_noise <- x_values_noise[1:timesteps]
x_t_noise <- x_values_noise[2:(timesteps + 1)]
plot(x_t_minus_1_noise, x_t_noise, type="o", col="green", pch=16, xlab=expression(x[t-1]), ylab=expression(x[t]), main="Plot of x_t vs x_{t-1} with Noise")
grid()
z_values <- c(-1.2, 0.2, -1.0, 0.5, 1.7, -0.5, -2.1, 1.0, 0.8, -0.1)
x_values_noise <- numeric(T)
# Load necessary library
library(ggplot2)
# Initial value
x0 <- 10
# Part (a): Compute the sequence xt = 0.8 * xt-1
t_values <- 0:10
x_values <- numeric(length(t_values))
x_values[1] <- x0
for (t in 2:length(t_values)) {
x_values[t] <- 0.8 * x_values[t-1]
}
# Extract x_t and x_{t-1}
x_t <- x_values[-1]  # Remove x0
x_t_minus_1 <- x_values[-length(x_values)]  # Remove last value
# Plot x_t vs. x_{t-1}
df1 <- data.frame(x_t_minus_1, x_t)
ggplot(df1, aes(x = x_t_minus_1, y = x_t)) +
geom_point(color = "blue") +
geom_line(color = "blue") +
labs(title = expression(x[t] ~ "vs." ~ x[t-1]),
x = expression(x[t-1]),
y = expression(x[t])) +
theme_minimal()
# Part (e): Plot x_t vs. x_{t-2}
x_t_minus_2 <- x_values[-c(length(x_values), length(x_values)-1)]  # Remove last two
x_t_2 <- x_values[-c(1,2)]  # Remove first two
df2 <- data.frame(x_t_minus_2, x_t_2)
ggplot(df2, aes(x = x_t_minus_2, y = x_t_2)) +
geom_point(color = "red") +
geom_line(color = "red") +
labs(title = expression(x[t] ~ "vs." ~ x[t-2]),
x = expression(x[t-2]),
y = expression(x[t])) +
theme_minimal()
# Part (f): Compute the noisy sequence xt = 0.8 * xt-1 + zt
z_values <- c(-1.2, 0.2, -1.0, 0.5, 1.7, -0.5, -2.1, 1.0, 0.8, -0.1)
x_values_noise <- numeric(length(t_values))
x_values_noise[1] <- x0
for (t in 2:length(t_values)) {
x_values_noise[t] <- 0.8 * x_values_noise[t-1] + z_values[t-1]
}
# Extract x_t and x_{t-1} for noisy data
x_t_noise <- x_values_noise[-1]
x_t_minus_1_noise <- x_values_noise[-length(x_values_noise)]
df3 <- data.frame(x_t_minus_1_noise, x_t_noise)
ggplot(df3, aes(x = x_t_minus_1_noise, y = x_t_noise)) +
geom_point(color = "green") +
geom_line(color = "green") +
labs(title = expression(x[t] ~ "vs." ~ x[t-1] ~ "with noise"),
x = expression(x[t-1]),
y = expression(x[t])) +
theme_minimal()
# Part (e) with noise: x_t vs. x_{t-2}
x_t_minus_2_noise <- x_values_noise[-c(length(x_values_noise), length(x_values_noise)-1)]
x_t_2_noise <- x_values_noise[-c(1,2)]
df4 <- data.frame(x_t_minus_2_noise, x_t_2_noise)
ggplot(df4, aes(x = x_t_minus_2_noise, y = x_t_2_noise)) +
geom_point(color = "purple") +
geom_line(color = "purple") +
labs(title = expression(x[t] ~ "vs." ~ x[t-2] ~ "with noise"),
x = expression(x[t-2]),
y = expression(x[t])) +
theme_minimal()
# Initial value
x0 <- 10
# Part (a): Compute the sequence xt = 0.8 * xt-1
t_values <- 0:10
x_values <- numeric(length(t_values))
x_values[1] <- x0
for (t in 2:length(t_values)) {
x_values[t] <- 0.8 * x_values[t-1]
}
# Extract x_t and x_{t-1}
x_t <- x_values[-1]  # Remove x0
x_t_minus_1 <- x_values[-length(x_values)]  # Remove last value
# Plot x_t vs. x_{t-1}
plot(x_t_minus_1, x_t, type="b", col="blue", pch=16,
xlab="x_{t-1}", ylab="x_t", main="x_t vs. x_{t-1}")
# Part (e): Plot x_t vs. x_{t-2}
x_t_minus_2 <- x_values[-c(length(x_values), length(x_values)-1)]  # Remove last two
x_t_2 <- x_values[-c(1,2)]  # Remove first two
plot(x_t_minus_2, x_t_2, type="b", col="red", pch=16,
xlab="x_{t-2}", ylab="x_t", main="x_t vs. x_{t-2}")
# Part (f): Compute the noisy sequence xt = 0.8 * xt-1 + zt
z_values <- c(-1.2, 0.2, -1.0, 0.5, 1.7, -0.5, -2.1, 1.0, 0.8, -0.1)
x_values_noise <- numeric(length(t_values))
x_values_noise[1] <- x0
for (t in 2:length(t_values)) {
x_values_noise[t] <- 0.8 * x_values_noise[t-1] + z_values[t-1]
}
# Extract x_t and x_{t-1} for noisy data
x_t_noise <- x_values_noise[-1]
x_t_minus_1_noise <- x_values_noise[-length(x_values_noise)]
plot(x_t_minus_1_noise, x_t_noise, type="b", col="green", pch=16,
xlab="x_{t-1}", ylab="x_t", main="x_t vs. x_{t-1} with noise")
# Part (e) with noise: x_t vs. x_{t-2}
x_t_minus_2_noise <- x_values_noise[-c(length(x_values_noise), length(x_values_noise)-1)]
x_t_2_noise <- x_values_noise[-c(1,2)]
plot(x_t_minus_2_noise, x_t_2_noise, type="b", col="purple", pch=16,
xlab="x_{t-2}", ylab="x_t", main="x_t vs. x_{t-2} with noise")
# Initial conditions
x_values <- numeric(11)
x_values[1] <- 2  # x0
x_values[2] <- 1  # x1
# Compute xt for t = 2 to 10 using recurrence relation xt = 0.8*xt-1 - 0.7*xt-2
for (t in 3:11) {
x_values[t] <- 0.8 * x_values[t-1] - 0.7 * x_values[t-2]
}
# Extract values for plotting
x_t <- x_values[3:11]      # From t=2 to 10
x_t_minus_1 <- x_values[2:10]  # From t=1 to 9
x_t_minus_2 <- x_values[1:9]   # From t=0 to 8
# Plot x_t vs. x_{t-1}
plot(x_t_minus_1, x_t, type="b", col="blue", pch=16,
xlab="x_{t-1}", ylab="x_t", main="x_t vs. x_{t-1}")
# Plot x_t vs. x_{t-2}
plot(x_t_minus_2, x_t, type="b", col="red", pch=16,
xlab="x_{t-2}", ylab="x_t", main="x_t vs. x_{t-2}")
# Part (d): Compute with noise
z_values <- c(-1.2, 0.2, -1.0, 0.5, 1.7, -0.5, -2.1, 1.0, 0.8, -0.1)
x_values_noise <- numeric(11)
x_values_noise[1] <- 2
x_values_noise[2] <- 1
for (t in 3:11) {
x_values_noise[t] <- 0.8 * x_values_noise[t-1] - 0.7 * x_values_noise[t-2] + z_values[t-2]
}
# Extract noisy values
x_t_noise <- x_values_noise[3:11]
x_t_minus_1_noise <- x_values_noise[2:10]
x_t_minus_2_noise <- x_values_noise[1:9]
# Plot x_t vs. x_{t-1} with noise
plot(x_t_minus_1_noise, x_t_noise, type="b", col="green", pch=16,
xlab="x_{t-1}", ylab="x_t", main="x_t vs. x_{t-1} with noise")
# Plot x_t vs. x_{t-2} with noise
plot(x_t_minus_2_noise, x_t_noise, type="b", col="purple", pch=16,
xlab="x_{t-2}", ylab="x_t", main="x_t vs. x_{t-2} with noise")
